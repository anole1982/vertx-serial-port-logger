= Vert.x serial port logger

This is a small example on how to use Vert.x to read data from a serial input/USB port and then push the data onto the event bus (see *SerialVerticle*).

Then there is a logger that listens on the event bus and logs the data to a database (*LoggerVerticle*)

There is also a simple panel that shows the various temperatures and current measurements that is being pushed to the event bus, this part uses the web browser client side event bus to read the data without having to resort to REST or similar techniques (see *PanelVerticle*)

The data is generated by an Arduino controller, the C++ file (.ino) is included in the project, but of course, any controller using serial output could be used as data source.

For the actual use case, the controller is hooked up to a Raspberry B+ (i.e. a single core 32 bit ARM processor with 512MB RAM).

Despite its limited compute power, the latest Raspian Jessie and the incl. Java 8 JDK works fine with Vert.x - putting "micro" back into micro service :-)

There is a systemd unit file in the *conf* directory which shows the options. Given the limited RAM setting JVM memory options is required.
Also, enabling clustering adds considerable to the start up time on a Raspberry so the Vert.x alert time (i.e. verticles blocking the event loop) should be be increased as indicated in the unit file.

The actual use case makes good use of the verticle "abstraction". The build product is a fat jar where the manifest names the *MainVerticle* as the main verticle.
This verticle reads the configuration and starts the verticles "enabled" in the configuration (those where the instance count is greater than zero).

Hence the same fat jar can be used on different servers taking on different roles depending on the config file. The server running the database starts the *LoggerVerticle*, whereas the Pi starts the *SerialVerticle* and the *PanelVerticle*.

Since the "backbone" is the distributed event bus, it is simply a matter of changing the config files to get the *PanelVerticle* to run on say the database server or perhaps a dedicated application server if the Pi is not quite up to the task of serving as web server.

The project also includes a *ReplayVerticle* which replay data from the database to the event bus. An easy way to get test data the event bus or run a demo at 10x real time.

There are a few Groovy scripts as well, useful for prototyping. While the vertx command line can run Java files directly, as usual the syntactic sugar in Groovy, just makes it easier to use for that purpose (assuming that you are familiar with Groovy of course :-)

__Note as of the time of writing (Groovy 2.4.7 / Vert.x 4.2.3) there is an issue when using Groovy classes for building the fat jar. The neat extensions added via Groovy is getting stripped it seems - so the magic that allows a [:] (Groovy's short hand for declaring a Map) to be used in place of JsonObject does not work. The same goes for a number of the other nice extensions that take advantage of Groovy. So while Groovy works fine when started with the *vertx* command line, using it for the fat jar is not as easy.__

== Prerequisites

* Java JDK 8+
* Vert.x 4.2


== Building the project

To build the project, just use:

----
./gradlew shadowJar
----

It generates a _fat-jar_ in the `build/libs` directory.

Please check the JavaDoc comments in the various verticles to see how to configure them.

Also check the JavaDoc and the systemd Unit file to see options for running the service.
